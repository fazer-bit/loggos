
# loggos

Обёртка стандартного logging для удобного создания экземпляров логгеров .

### Лицензия
>* MIT
### Инсталляция
    pip install git+https://github.com/fazer-bit/fazer-utils.git
## Утилиты
### fazer_utils.timers
* **TimerPlus**
>
>       from fazer_utils.timers import TimerPlus
>    
>       tm = TimerPlus(10)  # 10 секунд при инициализации.
>       tm.set_sec(5)  # изменить количество секунд на 5.
>       tm.reset()  # обнулить таймер и запустить вновь.
>       res = tm.get()  # возвращает кортеж (bool, float)
>                       # [0] возвратит False, если прошло менее 5 секунд
>                           # или True, если более.        
>                       # [1] возвратит положительное количество секунд, которое 
>                           # сталось до достижения временной отметки
>                           # или отрицательное, если отметка пройдена.
> После обнуления таймера сразу же запускается новый отсчёт.
> При запросе отдаёт False, если указанное количество секунд не достигнуто 
> или True, если временная отметка пройдена.

* **TimerMinus**
>
> Полный аналог **TimerPlus**, за исключением того, что 
> **get()[0]** отдаёт **True**, если временная отметка не достигнута и
> **False** в случае прохождения.


* **TimerStep**
>
>       from fazer_utils.timers import TimerStep
>    
>       tm = TimerStep(1, 50, 1.5)  # минимум=1, максимум=50, множитель=1.5
>       tm.set_timer(5, 30, 2)  # изменить настройки таймера.
>       tm.reset()  # начать новый отсчёт с минимума.
>       tm.step()  # начать новый отсчёт с текущий * множитель.
>       res = tm.get()  # возвращает кортеж (bool, float)
>                       # [0] возвратит False, если прошло менее 5 секунд
>                           # или True, если более.        
>                       # [1] возвратит положительное количество секунд, которое 
>                           # сталось до достижения временной отметки
>                           # или отрицательное, если отметка пройдена.
> Таймер начинает новый отсчёт с минимума. При применении метода **step()**
> таймер перезапускается с увеличенным промежутком времени, который 
> высчитывается, как текущий * множитель. При достижении текущим промежутком
> максимума увеличение прекращается.
> Метод **reset()** перезапускает таймер с минимума.
> **TimerStep** полезен, как таймаут, при множественных ошибках подключения к сети.

* **TimerLast**
>
>       from fazer_utils.timers import TimerLast
>    
>       tm = TimerLast()
>       tm.reset()  # начинает новый отсчёт с нуля.
>       res = tm.get()  # возвратит положительное количество секунд
>                       # прошедшее с момента последнего reset().
> Таймер позвращает время в секундах между **reset()** и **get()**